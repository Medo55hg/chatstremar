<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="UTF-8">
<title>ğŸŒ Ø­Ø±Ø¨ Ø§Ù„Ø¯ÙˆÙ„</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Cairo&display=swap" rel="stylesheet">
<script src="tmi.min.js"></script>
<style>
body {
    background: linear-gradient(-45deg, #1a1a3d, #004466, #1a1a3d, #004466);
    background-size: 400% 400%;
    animation: gradientBG 20s ease infinite;
    color: #fff;
    font-family: 'Cairo', sans-serif;
    text-align: center;
    padding: 20px;
}
@keyframes gradientBG {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}
.container { display:flex; justify-content:space-between; flex-wrap:wrap; }
.wheel, .countries {
  width:48%; min-height:300px; border:2px solid #fff;
  border-radius:8px; padding:10px; overflow:auto; position:relative;
}
#countryList {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 10px;
}
.country {
  width: calc(25% - 10px);
  background:#222;
  padding:5px;
  border-radius:6px;
  text-align:center;
  opacity:0;
  transform: scale(0.5);
  transition: all 0.4s ease;
  position: relative;
}
.country.show { opacity:1; transform: scale(1); }
.country img { width:80px; display:block; margin:auto; }
.overlay {
  position:fixed; top:0;left:0;right:0;bottom:0;
  background:rgba(0,0,0,0.8);
  display:none; align-items:center; justify-content:center;
  font-size:24px; z-index:999;
}
button {
  padding:10px 20px; margin-top:15px;
  background:#ff3333; color:#fff;
  border:none; border-radius:6px;
  cursor:pointer; font-family:'Cairo', sans-serif;
}
h1 {
    font-size: 36px;
    color: #ff3333;
    margin-bottom: 30px;
}
.eliminated-section {
    margin-top: 30px;
    padding: 15px;
    background: rgba(255, 0, 0, 0.2);
    border-radius: 8px;
    border: 1px solid #ff0000;
}
.eliminated-title {
    color: #ff0000;
    font-size: 24px;
    margin-bottom: 10px;
}
.eliminated-content {
    color: #ff9999;
    font-size: 18px;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 10px;
}
.eliminated-item {
    background: rgba(255, 0, 0, 0.3);
    padding: 5px 10px;
    border-radius: 5px;
    margin: 5px;
}
.revive-section {
    margin-top: 20px;
    padding: 15px;
    background: rgba(0, 255, 0, 0.2);
    border-radius: 8px;
    border: 1px solid #00ff00;
}
.revive-title {
    color: #00ff00;
    font-size: 24px;
    margin-bottom: 10px;
}
.revive-select {
    padding: 8px;
    font-size: 16px;
    margin-right: 10px;
    border-radius: 5px;
    border: none;
}
.revive-button {
    background: #28a745;
    color: white;
    padding: 8px 15px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-family: 'Cairo', sans-serif;
}
.spin-time-select {
    margin-top: 10px;
    padding: 8px;
    font-size: 16px;
    border-radius: 5px;
    border: none;
}
</style>
</head>
<body>
<h1>ğŸŒ Ù„Ø¹Ø¨Ø© Ø­Ø±Ø¨ Ø§Ù„Ø¯ÙˆÙ„</h1>
<p>Ø§Ø®ØªØ± Ø§Ù„Ù…Ù†ØµØ© ÙˆØ£Ø±Ø³Ù„ "!Ø¯Ø®ÙˆÙ„" ÙÙŠ Ø§Ù„Ø´Ø§Øª Ù„Ù„Ø§Ù†Ø¶Ù…Ø§Ù…</p>
<div class="container">
  <div class="wheel" id="wheel">
    <h3>ğŸ‘¥ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†</h3>
    <p style="font-size:14px; color:#ccc;">Ø³ÙŠÙƒÙˆÙ† Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ø£Ø³Ù…Ø§Ø¡ Ø¹Ø´ÙˆØ§Ø¦ÙŠÙ‹Ø§</p>
    <canvas id="playerWheel" width="400" height="400" style="margin: 20px auto; display: block;"></canvas>
    <div>
      <select id="spinTimeSelect" class="spin-time-select">
        <option value="10">10 Ø«ÙˆØ§Ù†ÙŠ</option>
        <option value="20">20 Ø«Ø§Ù†ÙŠØ©</option>
        <option value="30">30 Ø«Ø§Ù†ÙŠØ©</option>
        <option value="40">40 Ø«Ø§Ù†ÙŠØ©</option>
        <option value="50">50 Ø«Ø§Ù†ÙŠØ©</option>
        <option value="60" selected>60 Ø«Ø§Ù†ÙŠØ©</option>
      </select>
      <button onclick="spinWheelAnimated()">ğŸ¯ Ø¯ÙˆØ±Ø§Ù† Ø§Ù„Ø¹Ø¬Ù„Ø©</button>
    </div>
  </div>
  <div class="countries" id="countries">
    <h3>ğŸŒ Ø§Ù„Ø¯ÙˆÙ„</h3>
    <div id="countryList"></div>
  </div>
</div>
<div class="overlay" id="overlay"></div>
<div style="margin-top:20px;">
  <select id="platformSelect" style="padding:10px;font-size:18px;">
    <option value="twitch">Twitch</option>
    <option value="kick">Kick</option>
  </select>
  <input type="text" id="channelInput" placeholder="ğŸ® Ø§ÙƒØªØ¨ Ø§Ø³Ù… Ø§Ù„Ù‚Ù†Ø§Ø©" style="padding:10px;font-size:18px;">
  <button onclick="connectChat()" style="padding:10px;font-size:18px;background:#28a745;color:#fff;border:none;border-radius:6px;cursor:pointer;">
    âœ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„
  </button>
  <div id="chatStatus" style="margin-top:10px;font-size:16px;color:#0f0;"></div>
</div>
<button onclick="startGame()">Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©</button>
<h3 id="currentTurnDisplay" style="margin-top:20px; color:#0ff;">âœ¨ Ø§Ù„Ø¯ÙˆØ± Ø§Ù„Ø¢Ù†: Ù„Ù… ÙŠØ¨Ø¯Ø£ Ø¨Ø¹Ø¯</h3>

<!-- Ù‚Ø³Ù… Ø§Ù„Ø¯ÙˆÙ„ Ø§Ù„Ù…Ù‚ØµØ§Ø© ÙˆØ§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„Ù…Ø·Ø±ÙˆØ¯ÙŠÙ† -->
<div class="eliminated-section" id="eliminatedSection">
    <h3 class="eliminated-title">ğŸš« Ø§Ù„Ø¯ÙˆÙ„ Ø§Ù„Ù…Ù‚ØµØ§Ø© ÙˆØ§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„Ù…Ø·Ø±ÙˆØ¯ÙŠÙ†</h3>
    <div class="eliminated-content" id="eliminatedContent">
        <div class="eliminated-item">Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø­Ø°ÙˆÙÙŠÙ† Ø¨Ø¹Ø¯</div>
    </div>
</div>

<!-- Ù‚Ø³Ù… Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† -->
<div class="revive-section" id="reviveSection">
    <h3 class="revive-title">â™»ï¸ Ø¥Ø¹Ø§Ø¯Ø© Ù„Ø§Ø¹Ø¨</h3>
    <select id="reviveSelect" class="revive-select">
        <option value="">Ø§Ø®ØªØ± Ù„Ø§Ø¹Ø¨Ø§Ù‹ Ù„Ø¥Ø¹Ø§Ø¯ØªÙ‡</option>
    </select>
    <button onclick="revivePlayer()" class="revive-button">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨</button>
    <p style="color:#ccc; margin-top:10px;">ÙŠÙ…ÙƒÙ†Ùƒ Ø£ÙŠØ¶Ø§Ù‹ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ù…Ø±: !Ø§Ø¹Ø§Ø¯Ù‡ @Ø§Ø³Ù…_Ø§Ù„Ù„Ø§Ø¹Ø¨</p>
</div>

<script>
let players = [], playerColors = {}, currentTurnPlayer = "";
let countriesPool = [
  "Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©","Ø§Ù„Ø¥Ù…Ø§Ø±Ø§Øª","Ù‚Ø·Ø±","Ù…ØµØ±","Ø§Ù„Ø£Ø±Ø¯Ù†","Ù„Ø¨Ù†Ø§Ù†","Ø§Ù„Ø¹Ø±Ø§Ù‚","Ø§Ù„ÙƒÙˆÙŠØª","Ø¹Ù…Ø§Ù†","Ø§Ù„Ø¨Ø­Ø±ÙŠÙ†",
  "ØªÙˆÙ†Ø³","Ø§Ù„Ø¬Ø²Ø§Ø¦Ø±","Ø§Ù„Ù…ØºØ±Ø¨","Ù„ÙŠØ¨ÙŠØ§","Ø§Ù„Ø³ÙˆØ¯Ø§Ù†","Ø§Ù„ÙŠÙ…Ù†","Ø³ÙˆØ±ÙŠØ§","ÙÙ„Ø³Ø·ÙŠÙ†","ØªØ±ÙƒÙŠØ§","Ø¥ÙŠØ±Ø§Ù†",
  "Ø£Ù„Ù…Ø§Ù†ÙŠØ§","ÙØ±Ù†Ø³Ø§","Ø¥ÙŠØ·Ø§Ù„ÙŠØ§","Ø¥Ø³Ø¨Ø§Ù†ÙŠØ§","Ø£Ù…Ø±ÙŠÙƒØ§","ÙƒÙ†Ø¯Ø§","Ø±ÙˆØ³ÙŠØ§","Ø§Ù„ØµÙŠÙ†","Ø§Ù„ÙŠØ§Ø¨Ø§Ù†","Ø§Ù„Ù‡Ù†Ø¯"
];
let assignedCountries = {}, remainingCountries = [], immunityCountries = [], reviveCountries = [], usedSpecialCountries = [];
let playerImmunity = {}, eliminatedPlayers = [], lastReviver = "";
let isGameStarted = false;
const overlay = document.getElementById("overlay");
let eliminatedData = [];
let countryAttackers = {};

function getColorForPlayer(player) {
  const hash = [...player].reduce((a, c) => a + c.charCodeAt(0), 0);
  return `hsl(${hash % 360}, 70%, 60%)`;
}

function addPlayer(name, color = "#fff") {
  if (!players.includes(name)) {
    players.push(name);
    playerColors[name] = color;
    renderPlayers();
  }
}

function renderPlayers(rotation = 0) {
  const canvas = document.getElementById("playerWheel");
  if (!canvas) return;
  const ctx = canvas.getContext("2d");
  const r = canvas.width / 2;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (players.length === 0) return;
  const slice = 2 * Math.PI / players.length;
  players.forEach((p, i) => {
    const angle = slice * i + rotation;
    ctx.beginPath(); ctx.moveTo(r, r);
    ctx.arc(r, r, r, angle, angle + slice);
    ctx.fillStyle = playerColors[p]; ctx.fill(); ctx.stroke();
    ctx.save(); ctx.translate(r, r); ctx.rotate(angle + slice / 2);
    ctx.textAlign = "right";
    ctx.fillStyle = "#000";
    ctx.font = "bold 14px Cairo";
    let displayName = p;
    if (playerImmunity[p]) displayName += " (Ù…Ø­ØµÙ†)";
    ctx.fillText(displayName, r - 10, 5); ctx.restore();
  });
  ctx.beginPath();
  ctx.moveTo(canvas.width - 20, r);
  ctx.lineTo(canvas.width, r - 20);
  ctx.lineTo(canvas.width, r + 20);
  ctx.closePath();
  ctx.fillStyle = "#ff0";
  ctx.fill();
}

function updateEliminatedDisplay() {
    const eliminatedContent = document.getElementById("eliminatedContent");
    const reviveSelect = document.getElementById("reviveSelect");
    
    eliminatedContent.innerHTML = "";
    reviveSelect.innerHTML = '<option value="">Ø§Ø®ØªØ± Ù„Ø§Ø¹Ø¨Ø§Ù‹ Ù„Ø¥Ø¹Ø§Ø¯ØªÙ‡</option>';
    
    if (eliminatedData.length === 0) {
        eliminatedContent.innerHTML = '<div class="eliminated-item">Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø­Ø°ÙˆÙÙŠÙ† Ø¨Ø¹Ø¯</div>';
        return;
    }
    
    eliminatedData.forEach(item => {
        const itemElement = document.createElement("div");
        itemElement.className = "eliminated-item";
        itemElement.textContent = `(${item.country}) ${item.player}`;
        eliminatedContent.appendChild(itemElement);
        
        const option = document.createElement("option");
        option.value = item.player;
        option.textContent = item.player;
        reviveSelect.appendChild(option);
    });
}

function revivePlayer() {
    const reviveSelect = document.getElementById("reviveSelect");
    const playerToRevive = reviveSelect.value;
    
    if (!playerToRevive) return;
    
    if (eliminatedPlayers.includes(playerToRevive)) {
        players.push(playerToRevive);
        playerColors[playerToRevive] = getColorForPlayer(playerToRevive);
        eliminatedPlayers = eliminatedPlayers.filter(x => x !== playerToRevive);
        eliminatedData = eliminatedData.filter(item => item.player !== playerToRevive);
        
        const availableCountries = countriesPool.filter(c => 
            !remainingCountries.includes(c) && 
            !usedSpecialCountries.includes(c)
        );
        
        if (availableCountries.length > 0) {
            const newCountry = availableCountries[Math.floor(Math.random() * availableCountries.length)];
            assignedCountries[newCountry] = playerToRevive;
            remainingCountries.push(newCountry);
            usedSpecialCountries.push(newCountry);
            
            shufflePlayersAndCountries();
            
            renderCountries();
            renderPlayers();
            updateEliminatedDisplay();
            
            overlay.innerText = `â™»ï¸ ØªÙ…Øª Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨ ${playerToRevive} Ø¨Ø¯ÙˆÙ„Ø© Ø¬Ø¯ÙŠØ¯Ø©`;
            overlay.style.display = "flex";
            setTimeout(() => overlay.style.display = "none", 3000);
        }
    }
}

function shufflePlayersAndCountries() {
    for (let i = players.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [players[i], players[j]] = [players[j], players[i]];
    }
    
    const shuffledCountries = [...remainingCountries].sort(() => Math.random() - 0.5);
    const newAssignedCountries = {};
    
    shuffledCountries.forEach((country, i) => {
        if (assignedCountries[country]) {
            const player = players[i % players.length];
            newAssignedCountries[country] = player;
        } else {
            newAssignedCountries[country] = null;
        }
    });
    
    assignedCountries = newAssignedCountries;
}

function spinWheelAnimated() {
  if (players.length === 0) return;
  
  const spinTimeSelect = document.getElementById("spinTimeSelect");
  const spinDuration = parseInt(spinTimeSelect.value) * 100; // ØªØ­ÙˆÙŠÙ„ Ø¥Ù„Ù‰ Ø¥Ø·Ø§Ø±Ø§Øª (ÙƒÙ„ Ø¥Ø·Ø§Ø± 10ms)
  
  let rotation = 0, frame = 0;
  const slice = 2 * Math.PI / players.length;
  const fullSpins = 5 * 2 * Math.PI;
  const randomAngle = Math.random() * 2 * Math.PI;
  const target = fullSpins + randomAngle;
  
  function animate() {
    frame++;
    const t = frame / spinDuration;
    const eased = t * t * (3 - 2 * t);
    rotation = target * eased;
    renderPlayers(rotation);
    
    if (frame < spinDuration) {
      requestAnimationFrame(animate);
    } else {
      const index = Math.floor(((2 * Math.PI - (rotation % (2 * Math.PI))) % (2 * Math.PI)) / slice);
      currentTurnPlayer = players[index];
      overlay.textContent = `ğŸ¯ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ù…Ø®ØªØ§Ø±: ${currentTurnPlayer}`;
      overlay.style.display = "flex";
      document.getElementById("currentTurnDisplay").innerText = `âœ¨ Ø§Ù„Ø¯ÙˆØ± Ø§Ù„Ø¢Ù†: ${currentTurnPlayer}`;
      setTimeout(() => overlay.style.display = "none", 3000);
    }
  }
  
  animate();
}

function startGame() {
  if (players.length < 2) return alert("ÙŠØ¬Ø¨ Ø¥Ø¶Ø§ÙØ© Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø£ÙˆÙ„Ø§Ù‹!");
  isGameStarted = true;
  
  assignedCountries = {};
  remainingCountries = [];
  immunityCountries = [];
  reviveCountries = [];
  playerImmunity = {};
  eliminatedPlayers = [];
  lastReviver = "";
  usedSpecialCountries = [];
  eliminatedData = [];
  countryAttackers = {};

  const totalNeeded = players.length + 4;
  const availableCountries = [...countriesPool];
  const selectedCountries = [];
  
  for (let i = 0; i < totalNeeded; i++) {
    if (availableCountries.length === 0) break;
    const randomIndex = Math.floor(Math.random() * availableCountries.length);
    selectedCountries.push(availableCountries[randomIndex]);
    availableCountries.splice(randomIndex, 1);
  }
  
  const specialCountries = [];
  while (specialCountries.length < 4 && selectedCountries.length > 0) {
    const randomIndex = Math.floor(Math.random() * selectedCountries.length);
    specialCountries.push(selectedCountries[randomIndex]);
    selectedCountries.splice(randomIndex, 1);
  }
  
  immunityCountries = specialCountries.slice(0, 2);
  reviveCountries = specialCountries.slice(2);
  usedSpecialCountries.push(...specialCountries);
  
  const playableCountries = [...selectedCountries];
  const shuffledPlayers = [...players];
  
  for (let i = shuffledPlayers.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffledPlayers[i], shuffledPlayers[j]] = [shuffledPlayers[j], shuffledPlayers[i]];
  }
  
  playableCountries.forEach((country, i) => {
    const player = shuffledPlayers[i % shuffledPlayers.length];
    assignedCountries[country] = player;
    remainingCountries.push(country);
  });
  
  remainingCountries.push(...specialCountries);
  specialCountries.forEach(country => {
    assignedCountries[country] = null;
  });

  renderCountries();
  renderPlayers();
  updateEliminatedDisplay();
  
  overlay.textContent = "ğŸ® Ø¨Ø¯Ø£Øª Ø§Ù„Ù„Ø¹Ø¨Ø©! ØªÙ… ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ø¯ÙˆÙ„ Ø¹Ø´ÙˆØ§Ø¦ÙŠØ§Ù‹";
  overlay.style.display = "flex";
  setTimeout(() => overlay.style.display = "none", 3000);
}

function renderCountries() {
  const box = document.getElementById("countryList");
  box.innerHTML = "";
  
  const shuffledCountries = [...remainingCountries].sort(() => Math.random() - 0.5);
  
  shuffledCountries.forEach((c, i) => {
    const div = document.createElement("div");
    div.className = "country";
    div.innerHTML = `<img src="https://flagcdn.com/w80/${getCountryCode(c)}.png"><br>${c}`;
    
    setTimeout(() => { box.appendChild(div); setTimeout(() => div.classList.add("show"), 50); }, i * 100);
  });
}

function attackCountry(c) {
  if (!remainingCountries.includes(c)) return;
  const p = assignedCountries[c];
  
  overlay.innerText = `ğŸ”´ ${currentTurnPlayer} Ù‡Ø§Ø¬Ù… Ø§Ù„Ø¯ÙˆÙ„Ø©: ${c}`;
  overlay.style.display = "flex";

  setTimeout(() => {
    if (playerImmunity[p] && currentTurnPlayer !== p) {
      playerImmunity[p] = false;
      overlay.innerText = `ğŸ›¡ï¸ ØªÙ… ÙƒØ³Ø± Ø§Ù„Ø­ØµØ§Ù†Ø© Ø¹Ù† ${p}`;
      shufflePlayersAndCountries();
      renderCountries(); 
      renderPlayers();
    }
    else if (immunityCountries.includes(c)) {
      playerImmunity[currentTurnPlayer] = true;
      immunityCountries = immunityCountries.filter(x => x !== c);
      usedSpecialCountries.push(c);
      remainingCountries = remainingCountries.filter(x => x !== c);
      delete assignedCountries[c];
      overlay.innerText = `âœ… ${currentTurnPlayer} Ø­ØµÙ„ Ø¹Ù„Ù‰ Ø­ØµØ§Ù†Ø©!`;
      renderCountries(); 
      renderPlayers();
    }
    else if (reviveCountries.includes(c)) {
      reviveCountries = reviveCountries.filter(x => x !== c);
      usedSpecialCountries.push(c);
      remainingCountries = remainingCountries.filter(x => x !== c);
      delete assignedCountries[c];
      lastReviver = currentTurnPlayer;
      overlay.innerText = `â™»ï¸ ${currentTurnPlayer} ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø¥Ø¹Ø§Ø¯Ø© Ù„Ø§Ø¹Ø¨ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… !Ø§Ø¹Ø§Ø¯Ù‡ @Ø§Ù„Ø§Ø³Ù…`;
      renderCountries();
    }
    else if (currentTurnPlayer === p) {
      // Ø¥Ø°Ø§ Ù‡Ø§Ø¬Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨ Ù†ÙØ³Ù‡
      overlay.innerText = `âŒ ${currentTurnPlayer} Ù‡Ø§Ø¬Ù… Ù†ÙØ³Ù‡!`;
      remainingCountries = remainingCountries.filter(x => x !== c);
      delete assignedCountries[c];
      const index = players.indexOf(p);
      if (index !== -1) players.splice(index, 1);
      delete playerColors[p];
      eliminatedPlayers.push(p);
      eliminatedData.push({ country: c, player: p });
      shufflePlayersAndCountries();
      renderPlayers(); 
      renderCountries();
      updateEliminatedDisplay();
    }
    else if (currentTurnPlayer !== p && p) {
      overlay.innerText = `âŒ ØªÙ… Ø¥Ù‚ØµØ§Ø¡ ${p} Ù…Ù† Ø§Ù„Ø¯ÙˆÙ„Ø© ${c}`;
      remainingCountries = remainingCountries.filter(x => x !== c);
      delete assignedCountries[c];
      const index = players.indexOf(p);
      if (index !== -1) players.splice(index, 1);
      delete playerColors[p];
      eliminatedPlayers.push(p);
      eliminatedData.push({ country: c, player: p });
      shufflePlayersAndCountries();
      renderPlayers(); 
      renderCountries();
      updateEliminatedDisplay();
    }
    setTimeout(() => overlay.style.display = "none", 3000);
  }, 3000);
}

function getCountryCode(n) {
  const codes = { "Ø§Ù„Ø³Ø¹ÙˆØ¯ÙŠØ©":"sa","Ø§Ù„Ø¥Ù…Ø§Ø±Ø§Øª":"ae","Ù‚Ø·Ø±":"qa","Ù…ØµØ±":"eg","Ø§Ù„Ø£Ø±Ø¯Ù†":"jo","Ù„Ø¨Ù†Ø§Ù†":"lb","Ø§Ù„Ø¹Ø±Ø§Ù‚":"iq","Ø§Ù„ÙƒÙˆÙŠØª":"kw","Ø¹Ù…Ø§Ù†":"om","Ø§Ù„Ø¨Ø­Ø±ÙŠÙ†":"bh","ØªÙˆÙ†Ø³":"tn","Ø§Ù„Ø¬Ø²Ø§Ø¦Ø±":"dz","Ø§Ù„Ù…ØºØ±Ø¨":"ma","Ù„ÙŠØ¨ÙŠØ§":"ly","Ø§Ù„Ø³ÙˆØ¯Ø§Ù†":"sd","Ø§Ù„ÙŠÙ…Ù†":"ye","Ø³ÙˆØ±ÙŠØ§":"sy","ÙÙ„Ø³Ø·ÙŠÙ†":"ps","ØªØ±ÙƒÙŠØ§":"tr","Ø¥ÙŠØ±Ø§Ù†":"ir","Ø£Ù„Ù…Ø§Ù†ÙŠØ§":"de","ÙØ±Ù†Ø³Ø§":"fr","Ø¥ÙŠØ·Ø§Ù„ÙŠØ§":"it","Ø¥Ø³Ø¨Ø§Ù†ÙŠØ§":"es","Ø£Ù…Ø±ÙŠÙƒØ§":"us","ÙƒÙ†Ø¯Ø§":"ca","Ø±ÙˆØ³ÙŠØ§":"ru","Ø§Ù„ØµÙŠÙ†":"cn","Ø§Ù„ÙŠØ§Ø¨Ø§Ù†":"jp","Ø§Ù„Ù‡Ù†Ø¯":"in" };
  return codes[n] || "un";
}

function connectChat() {
  const plat = document.getElementById("platformSelect").value;
  const channel = document.getElementById("channelInput").value.trim();

  if (plat === "twitch") {
    const client = new tmi.Client({ channels: [channel] });
    client.connect();
    client.on("message", (ch, tags, msg, self) => {
      if (self) return;
      const user = tags["display-name"];
      const color = tags["color"] || "#fff";
      const content = msg.trim();

      if (content === "!Ø¯Ø®ÙˆÙ„" && !isGameStarted) addPlayer(user, color);
      if (isGameStarted && currentTurnPlayer === user && countriesPool.includes(content)) {
        attackCountry(content);
      }
      if ((msg.startsWith("!Ø§Ø¹Ø§Ø¯Ù‡") || msg.startsWith("!Ø¥Ø¹Ø§Ø¯Ù‡")) && user === lastReviver) {
        const mentioned = msg.split("@")[1]?.trim();
        if (mentioned && eliminatedPlayers.includes(mentioned)) {
          players.push(mentioned);
          playerColors[mentioned] = getColorForPlayer(mentioned);
          eliminatedPlayers = eliminatedPlayers.filter(x => x !== mentioned);
          eliminatedData = eliminatedData.filter(item => item.player !== mentioned);
          
          const availableCountries = countriesPool.filter(c => 
              !remainingCountries.includes(c) && 
              !usedSpecialCountries.includes(c)
          );
          
          if (availableCountries.length > 0) {
              const newCountry = availableCountries[Math.floor(Math.random() * availableCountries.length)];
              assignedCountries[newCountry] = mentioned;
              remainingCountries.push(newCountry);
              usedSpecialCountries.push(newCountry);
              shufflePlayersAndCountries();
              renderCountries();
              renderPlayers();
              updateEliminatedDisplay();
              overlay.innerText = `â™»ï¸ ØªÙ…Øª Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨ ${mentioned} Ø¨Ø¯ÙˆÙ„Ø© Ø¬Ø¯ÙŠØ¯Ø©`;
              overlay.style.display = "flex";
              setTimeout(() => overlay.style.display = "none", 3000);
          }
        }
      }
    });
    document.getElementById("chatStatus").innerText = "âœ… ØªÙ… Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù€Twitch!";
  }

  else if (plat === "kick") {
    fetch(`https://kick.com/api/v2/channels/${channel}`)
      .then(res => res.json())
      .then(data => {
        const roomId = data.chatroom.id;
        const socket = new WebSocket("wss://ws-us2.pusher.com/app/32cbd69e4b950bf97679?protocol=7&client=js&version=8.4.0-rc2");

        socket.onopen = () => {
          socket.send(JSON.stringify({ event: "pusher:subscribe", data: { auth: "", channel: `chatrooms.${roomId}.v2` } }));
          setInterval(() => {
            if (socket.readyState === WebSocket.OPEN)
              socket.send(JSON.stringify({ event: "pusher:ping", data: {} }));
          }, 12000);
        };

        socket.onmessage = (e) => {
          const msg = JSON.parse(e.data);
          if (msg.event === "App\\Events\\ChatMessageEvent") {
            const d = JSON.parse(msg.data);
            const user = d.sender.username;
            const content = d.content.trim();

            if (content === "!Ø¯Ø®ÙˆÙ„" && !isGameStarted) addPlayer(user);
            if (isGameStarted && currentTurnPlayer === user && countriesPool.includes(content)) {
              attackCountry(content);
            }
            if ((content.startsWith("!Ø§Ø¹Ø§Ø¯Ù‡") || content.startsWith("!Ø¥Ø¹Ø§Ø¯Ù‡")) && user === lastReviver) {
              const mentioned = content.split("@")[1]?.trim();
              if (mentioned && eliminatedPlayers.includes(mentioned)) {
                players.push(mentioned);
                playerColors[mentioned] = getColorForPlayer(mentioned);
                eliminatedPlayers = eliminatedPlayers.filter(x => x !== mentioned);
                eliminatedData = eliminatedData.filter(item => item.player !== mentioned);
                
                const availableCountries = countriesPool.filter(c => 
                    !remainingCountries.includes(c) && 
                    !usedSpecialCountries.includes(c)
                );
                
                if (availableCountries.length > 0) {
                    const newCountry = availableCountries[Math.floor(Math.random() * availableCountries.length)];
                    assignedCountries[newCountry] = mentioned;
                    remainingCountries.push(newCountry);
                    usedSpecialCountries.push(newCountry);
                    shufflePlayersAndCountries();
                    renderCountries();
                    renderPlayers();
                    updateEliminatedDisplay();
                    overlay.innerText = `â™»ï¸ ØªÙ…Øª Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù„Ø§Ø¹Ø¨ ${mentioned} Ø¨Ø¯ÙˆÙ„Ø© Ø¬Ø¯ÙŠØ¯Ø©`;
                    overlay.style.display = "flex";
                    setTimeout(() => overlay.style.display = "none", 3000);
                }
              }
            }
          }
        };

        document.getElementById("chatStatus").innerText = "âœ… ØªÙ… Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù€Kick!";
      })
      .catch(err => {
        console.error("Kick connection error:", err);
        document.getElementById("chatStatus").innerText = "âŒ ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù€Kick!";
      });
  }
}
</script>
</body>
</html>
